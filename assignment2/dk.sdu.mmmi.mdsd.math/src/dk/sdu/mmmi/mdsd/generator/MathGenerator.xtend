/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.Exp
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.Var
import dk.sdu.mmmi.mdsd.math.MyNumber
import dk.sdu.mmmi.mdsd.math.Let
import dk.sdu.mmmi.mdsd.math.In
import dk.sdu.mmmi.mdsd.math.MyString
import java.util.HashMap
import java.util.Map
import javax.swing.JOptionPane
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.End

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables = new HashMap();
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val result = math.compute
		
		// You can replace with hovering, see Bettini Chapter 8
		result.displayPanel
	}
	
	//
	// Compute function: computes value of expression
	// Note: written according to illegal left-recursive grammar, requires fix
	//
	
	def static compute(MathExp math) { 
		math.exp.computeExp
		return variables
	}
	
	def static int computeExp(Exp exp) {
		/*
		 switch exp.operator {			
			Plus: left+exp.right.computePrim
			Minus: left-exp.right.computePrim
			Mult: left*exp.right.computePrim
			Div: left/exp.right.computePrim
			default: left
		}
		 */
		if (exp instanceof Plus) {
			return exp.left.computeExp + exp.right.computeExp
		} else if (exp instanceof Minus) {
			return exp.left.computeExp - exp.right.computeExp
		} else if (exp instanceof Mult) {
			return exp.left.computeExp * exp.right.computeExp
		} else if (exp instanceof Div) {
			return exp.left.computeExp / exp.right.computeExp
		} else if (exp instanceof MyNumber) {
			return exp.value
		} else if (exp instanceof MyString) {
			return variables.get(exp.value)
		} else if (exp instanceof Var) {
			exp.left.computeExp
			var value = exp.right.computeExp
			variables.put(exp.name, value)
			return 0
		} else if (exp instanceof Let) {
			println("Left: " + exp.left.computeExp)
			println("Right: " + exp.right.computeExp)
			println("Combined: " + exp.left.computeExp + exp.right.computeExp)
			exp.left.computeExp
			var value = exp.right.computeExp
			variables.put(exp.name, value)
			return 0
		} else if (exp instanceof In) {
			return exp.left.computeExp + exp.right.computeExp
		} else if (exp instanceof End) {
			return exp.left.computeExp + exp.right.computeExp
		} else {
			return 0
		}
	}
	
	/*
	 	def static int computePrim(Primary factor) { 
			87
		}
	 */

	def void displayPanel(Map<String, Integer> result) {
		var resultString = ""
		for (entry : result.entrySet()) {
         	resultString += "var " + entry.getKey() + " = " + entry.getValue() + "\n"
        }
		
		JOptionPane.showMessageDialog(null, resultString ,"Math Language", JOptionPane.INFORMATION_MESSAGE)
	}
}
